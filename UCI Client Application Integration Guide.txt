Client Application Integration Guide#
This guide explains how to integrate your web or mobile application with UCI for user authentication using the OAuth2 Authorization Code flow with PKCE.

Overview#
UCI provides a hosted authentication UI similar to Auth0's Universal Login. Your application redirects users to UCI for authentication, and UCI redirects back with an authorization code that you exchange for tokens.

Flow Summary:

User clicks "Login" in your app
Your app redirects to UCI /oauth2/authorize
User authenticates on UCI (login or signup)
If TOTP 2FA is enabled, user enters authenticator code
User approves access on the consent screen
UCI redirects back to your app with an authorization code
Your app exchanges the code for access and refresh tokens
Your app uses the access token to make API requests
Prerequisites#
Access to UCI (production: https://uci.space/)
An OAuth2 client registered with UCI
Your application's callback URL configured as a redirect URI
Step 1: Register an OAuth2 Client#
OAuth2 clients belong to applications. You can create clients via the Admin UI at /admin/applications/{slug}/clients, or via the API.

Using the Admin UI (Recommended)#
Log in to UCI and go to Admin → Applications
Select your application (or create one)
Go to OAuth2 Clients → Create Client
Set client type to Public for SPAs/mobile apps
Add your redirect URIs
Save the client_id
Using the API#
First, you need an application. Then create a client for that application:

bash
# Create an OAuth2 client for an application
curl -X POST "https://uci.space/api/v1/oauth2/clients?application_id=YOUR_APP_ID" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <access_token>" \
  -d '{
    "client_name": "My Web Application",
    "client_type": "public",
    "redirect_uris": [
      "http://localhost:3000/callback",
      "http://localhost:3000/auth/callback"
    ],
    "allowed_scopes": ["openid", "profile"],
    "logo_uri": "https://example.com/logo.png",
    "client_uri": "https://example.com"
  }'
Response:

json
{
  "client_id": "abc123xyz...",
  "client_name": "My Web Application",
  "client_type": "public",
  "redirect_uris": ["http://localhost:3000/callback"],
  "require_pkce": true
}
Save the client_id - you'll need it in your application.

Client Types#
Type	Use Case	Secret	PKCE
public	SPAs, mobile apps, native apps	No	Required
confidential	Server-side web apps	Yes	Optional
Step 2: Implement PKCE#
PKCE (Proof Key for Code Exchange) prevents authorization code interception attacks. It's required for public clients.

Generate Code Verifier and Challenge#
javascript
// Generate a random code verifier (43-128 characters)
function generateCodeVerifier() {
  const array = new Uint8Array(32);
  crypto.getRandomValues(array);
  return base64UrlEncode(array);
}

// Create the code challenge from the verifier
async function generateCodeChallenge(verifier) {
  const encoder = new TextEncoder();
  const data = encoder.encode(verifier);
  const hash = await crypto.subtle.digest('SHA-256', data);
  return base64UrlEncode(new Uint8Array(hash));
}

// Base64 URL encoding (no padding)
function base64UrlEncode(buffer) {
  return btoa(String.fromCharCode(...buffer))
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=+$/, '');
}
Step 3: Redirect to Authorization#
When the user wants to log in, redirect them to the UCI authorization endpoint:

javascript
async function login() {
  // Generate PKCE values
  const codeVerifier = generateCodeVerifier();
  const codeChallenge = await generateCodeChallenge(codeVerifier);

  // Store verifier for later (needed to exchange the code)
  sessionStorage.setItem('pkce_code_verifier', codeVerifier);

  // Generate state for CSRF protection
  const state = crypto.randomUUID();
  sessionStorage.setItem('oauth_state', state);

  // Build authorization URL
  const params = new URLSearchParams({
    response_type: 'code',
    client_id: 'YOUR_CLIENT_ID',
    redirect_uri: window.location.origin + '/callback',
    scope: 'openid profile',
    state: state,
    code_challenge: codeChallenge,
    code_challenge_method: 'S256'
  });

  // Redirect to UCI
  window.location.href = `https://uci.space/oauth2/authorize?${params}`;
}
Authorization Parameters#
Parameter	Required	Description
response_type	Yes	Must be code
client_id	Yes	Your OAuth2 client ID
redirect_uri	Yes	Must match a registered redirect URI
scope	No	Space-separated list of scopes
state	Recommended	Random string for CSRF protection
code_challenge	Yes*	PKCE challenge (*required for public clients)
code_challenge_method	Yes*	Must be S256
nonce	No	For OpenID Connect ID tokens
Available Scopes#
Scope	Description
openid	Required for OpenID Connect
profile	Access to user profile information (name, username)
email	Access to user email
offline_access	Request a refresh token
discord	Access to linked Discord account (id, username, avatar)
rsi	Access to linked RSI account (handle, verified status)
Note: Additional custom scopes can be configured per API resource.

Targeting API Resources (Audience)#
If you're targeting a specific API resource, include the audience parameter:

javascript
const params = new URLSearchParams({
  response_type: 'code',
  client_id: 'YOUR_CLIENT_ID',
  redirect_uri: window.location.origin + '/callback',
  scope: 'openid profile',
  audience: 'https://api.example.com',  // Optional: target specific API
  state: state,
  code_challenge: codeChallenge,
  code_challenge_method: 'S256'
});
When an audience is specified, the access token will include the audience in the aud claim, and only scopes associated with that API resource will be included.

Step 4: Handle the Callback#
After the user authenticates and approves access, UCI redirects to your callback URL:


http://localhost:3000/callback?code=AUTHORIZATION_CODE&state=STATE_VALUE
Handle this callback to exchange the code for tokens:

javascript
async function handleCallback() {
  const params = new URLSearchParams(window.location.search);

  // Check for errors
  const error = params.get('error');
  if (error) {
    const errorDescription = params.get('error_description');
    console.error(`OAuth error: ${error} - ${errorDescription}`);
    // Handle error (show message, redirect to login, etc.)
    return;
  }

  // Verify state to prevent CSRF
  const state = params.get('state');
  const savedState = sessionStorage.getItem('oauth_state');
  if (state !== savedState) {
    console.error('State mismatch - possible CSRF attack');
    return;
  }

  // Get the authorization code
  const code = params.get('code');
  const codeVerifier = sessionStorage.getItem('pkce_code_verifier');

  // Exchange code for tokens
  const tokens = await exchangeCodeForTokens(code, codeVerifier);

  // Clean up
  sessionStorage.removeItem('pkce_code_verifier');
  sessionStorage.removeItem('oauth_state');

  // Store tokens and redirect to app
  storeTokens(tokens);
  window.location.href = '/dashboard';
}
Step 5: Exchange Code for Tokens#
javascript
async function exchangeCodeForTokens(code, codeVerifier) {
  const response = await fetch('https://uci.space/api/v1/oauth2/token', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
    },
    body: new URLSearchParams({
      grant_type: 'authorization_code',
      code: code,
      redirect_uri: window.location.origin + '/callback',
      client_id: 'YOUR_CLIENT_ID',
      code_verifier: codeVerifier,
    }),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(`Token exchange failed: ${error.error_description}`);
  }

  return response.json();
}
Response:

json
{
  "access_token": "eyJhbGciOiJSUzI1NiIs...",
  "token_type": "Bearer",
  "expires_in": 900,
  "refresh_token": "eyJhbGciOiJSUzI1NiIs...",
  "scope": "openid profile"
}
Step 6: Use the Access Token#
Include the access token in API requests:

javascript
async function fetchUserProfile() {
  const accessToken = getStoredAccessToken();

  const response = await fetch('https://uci.space/api/v1/auth/me', {
    headers: {
      'Authorization': `Bearer ${accessToken}`,
    },
  });

  if (response.status === 401) {
    // Token expired - refresh it
    await refreshAccessToken();
    return fetchUserProfile();
  }

  return response.json();
}
Step 7: Refresh Tokens#
When the access token expires, use the refresh token to get a new one:

javascript
async function refreshAccessToken() {
  const refreshToken = getStoredRefreshToken();

  const response = await fetch('https://uci.space/api/v1/oauth2/token', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
    },
    body: new URLSearchParams({
      grant_type: 'refresh_token',
      refresh_token: refreshToken,
      client_id: 'YOUR_CLIENT_ID',
    }),
  });

  if (!response.ok) {
    // Refresh token expired or revoked - user must log in again
    logout();
    return;
  }

  const tokens = await response.json();
  storeTokens(tokens);
  return tokens;
}
Important: The old refresh token is revoked when a new one is issued. Always store the new refresh token.

Step 8: Logout#
To log out, revoke the tokens and clear local storage:

javascript
async function logout() {
  const accessToken = getStoredAccessToken();

  // Revoke the token (optional but recommended)
  try {
    await fetch('https://uci.space/api/v1/oauth2/revoke', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: new URLSearchParams({
        token: accessToken,
        client_id: 'YOUR_CLIENT_ID',
      }),
    });
  } catch (e) {
    // Revocation failed, but continue with logout
  }

  // Clear stored tokens
  clearStoredTokens();

  // Redirect to login or home
  window.location.href = '/';
}
Complete React Example#
auth.js
CallbackPage.jsx
javascript
// auth.js - Authentication utilities
const UCI_URL = 'https://uci.space';
const CLIENT_ID = 'your_client_id';
const REDIRECT_URI = window.location.origin + '/callback';

export async function login() {
  const codeVerifier = generateCodeVerifier();
  const codeChallenge = await generateCodeChallenge(codeVerifier);
  const state = crypto.randomUUID();

  sessionStorage.setItem('pkce_code_verifier', codeVerifier);
  sessionStorage.setItem('oauth_state', state);

  const params = new URLSearchParams({
    response_type: 'code',
    client_id: CLIENT_ID,
    redirect_uri: REDIRECT_URI,
    scope: 'openid profile',
    state,
    code_challenge: codeChallenge,
    code_challenge_method: 'S256',
  });

  window.location.href = `${UCI_URL}/oauth2/authorize?${params}`;
}

export async function handleCallback() {
  const params = new URLSearchParams(window.location.search);

  if (params.get('error')) {
    throw new Error(params.get('error_description') || params.get('error'));
  }

  const state = params.get('state');
  if (state !== sessionStorage.getItem('oauth_state')) {
    throw new Error('Invalid state parameter');
  }

  const code = params.get('code');
  const codeVerifier = sessionStorage.getItem('pkce_code_verifier');

  const response = await fetch(`${UCI_URL}/api/v1/oauth2/token`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      grant_type: 'authorization_code',
      code,
      redirect_uri: REDIRECT_URI,
      client_id: CLIENT_ID,
      code_verifier: codeVerifier,
    }),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error_description || 'Token exchange failed');
  }

  const tokens = await response.json();

  sessionStorage.removeItem('pkce_code_verifier');
  sessionStorage.removeItem('oauth_state');

  localStorage.setItem('access_token', tokens.access_token);
  localStorage.setItem('refresh_token', tokens.refresh_token);
  localStorage.setItem('token_expires_at', Date.now() + tokens.expires_in * 1000);

  return tokens;
}

export function getAccessToken() {
  return localStorage.getItem('access_token');
}

export function isAuthenticated() {
  const token = getAccessToken();
  const expiresAt = localStorage.getItem('token_expires_at');
  return token && expiresAt && Date.now() < parseInt(expiresAt);
}

export function logout() {
  localStorage.removeItem('access_token');
  localStorage.removeItem('refresh_token');
  localStorage.removeItem('token_expires_at');
  window.location.href = '/';
}

// Helper functions
function generateCodeVerifier() {
  const array = new Uint8Array(32);
  crypto.getRandomValues(array);
  return base64UrlEncode(array);
}

async function generateCodeChallenge(verifier) {
  const encoder = new TextEncoder();
  const data = encoder.encode(verifier);
  const hash = await crypto.subtle.digest('SHA-256', data);
  return base64UrlEncode(new Uint8Array(hash));
}

function base64UrlEncode(buffer) {
  return btoa(String.fromCharCode(...buffer))
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=+$/, '');
}
Error Handling#
Authorization Errors#
If authorization fails, UCI redirects with error parameters:


http://localhost:3000/callback?error=access_denied&error_description=User+denied+access
Common errors:

Error	Description
access_denied	User denied the authorization request
invalid_request	Missing or invalid parameters
invalid_client	Unknown client_id
invalid_scope	Requested scope is invalid
server_error	Internal server error
Token Errors#
Token endpoint errors return JSON:

json
{
  "error": "invalid_grant",
  "error_description": "Authorization code has expired"
}
Common errors:

Error	Description
invalid_grant	Code expired, already used, or invalid
invalid_client	Client authentication failed
invalid_request	Missing required parameter
Security Best Practices#
Always use PKCE for public clients (SPAs, mobile apps)
Validate the state parameter to prevent CSRF attacks
Store tokens securely - use httpOnly cookies for server-side apps
Never expose tokens in URLs or logs
Implement token refresh before expiration
Revoke tokens on logout when possible
Use short-lived access tokens (default: 15 minutes)
Encourage MFA - Users can enable TOTP 2FA in their account settings
WebAuthn / Passkey Authentication#
UCI supports passwordless authentication using WebAuthn/Passkeys. Users can register passkeys from their account settings and use them for login.

How It Works#
User visits the login page
User clicks "Sign in with Passkey"
Browser prompts for passkey authentication (fingerprint, face ID, security key, etc.)
User is authenticated and redirected
Passkey Registration#
Users must first authenticate with their HLN ID and password, then can register passkeys from the account management UI at /account/passkeys.

API Endpoints#
For custom implementations, the WebAuthn API is available:

javascript
// 1. Get registration options
const optionsResponse = await fetch('/api/v1/auth/webauthn/register/options', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${sessionToken}`,
    'Content-Type': 'application/json'
  }
});
const options = await optionsResponse.json();

// 2. Use the browser's WebAuthn API
const credential = await navigator.credentials.create({
  publicKey: options
});

// 3. Verify registration
await fetch('/api/v1/auth/webauthn/register/verify', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${sessionToken}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    credential: credential,
    name: 'My MacBook'  // Optional friendly name
  })
});
Authentication Flow#
javascript
// 1. Get authentication options
const optionsResponse = await fetch('/api/v1/auth/webauthn/authenticate/options', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ hln_id: 'AL-05-1234' })  // Optional, for user hint
});
const options = await optionsResponse.json();

// 2. Use the browser's WebAuthn API
const assertion = await navigator.credentials.get({
  publicKey: options
});

// 3. Verify authentication
const verifyResponse = await fetch('/api/v1/auth/webauthn/authenticate/verify', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ credential: assertion })
});
const { session_token, user } = await verifyResponse.json();
Using OAuth2 Libraries#
Instead of implementing OAuth2 manually, you can use well-maintained OAuth2 libraries that handle PKCE, state validation, and token management automatically.

Python with Authlib#
Authlibis a comprehensive OAuth2/OIDC library for Python.

bash
pip install authlib httpx
Flask
FastAPI
Async (httpx)
python
from flask import Flask, redirect, url_for, session
from authlib.integrations.flask_client import OAuth

app = Flask(__name__)
app.secret_key = 'your-secret-key'

oauth = OAuth(app)
oauth.register(
    name='uci',
    client_id='YOUR_CLIENT_ID',
    client_secret=None,  # Public client
    server_metadata_url='https://uci.space/.well-known/openid-configuration',
    client_kwargs={
        'scope': 'openid profile',
        'code_challenge_method': 'S256',
    },
)


@app.route('/login')
def login():
    redirect_uri = url_for('callback', _external=True)
    return oauth.uci.authorize_redirect(redirect_uri)


@app.route('/callback')
def callback():
    token = oauth.uci.authorize_access_token()
    session['user'] = token.get('userinfo')
    session['access_token'] = token['access_token']
    return redirect('/dashboard')


@app.route('/logout')
def logout():
    session.clear()
    return redirect('/')
TypeScript/JavaScript with oauth4webapi#
oauth4webapiis a modern, standards-compliant OAuth2 library.

bash
npm install oauth4webapi
Browser/SPA
Node.js/Express
typescript
import * as oauth from 'oauth4webapi';

const issuer = new URL('https://uci.space');
const clientId = 'YOUR_CLIENT_ID';
const redirectUri = 'http://localhost:3000/callback';

// Discover authorization server metadata
async function getAuthServer() {
  return await oauth.discoveryRequest(issuer).then((response) =>
    oauth.processDiscoveryResponse(issuer, response)
  );
}

// Start login flow
async function login() {
  const as = await getAuthServer();

  // Generate PKCE code verifier and challenge
  const codeVerifier = oauth.generateRandomCodeVerifier();
  const codeChallenge = await oauth.calculatePKCECodeChallenge(codeVerifier);
  const state = oauth.generateRandomState();

  // Store for callback
  sessionStorage.setItem('code_verifier', codeVerifier);
  sessionStorage.setItem('state', state);

  const authUrl = new URL(as.authorization_endpoint!);
  authUrl.searchParams.set('response_type', 'code');
  authUrl.searchParams.set('client_id', clientId);
  authUrl.searchParams.set('redirect_uri', redirectUri);
  authUrl.searchParams.set('scope', 'openid profile');
  authUrl.searchParams.set('state', state);
  authUrl.searchParams.set('code_challenge', codeChallenge);
  authUrl.searchParams.set('code_challenge_method', 'S256');

  window.location.href = authUrl.toString();
}

// Handle callback
async function handleCallback() {
  const as = await getAuthServer();
  const client: oauth.Client = { client_id: clientId };

  const currentUrl = new URL(window.location.href);
  const codeVerifier = sessionStorage.getItem('code_verifier')!;
  const state = sessionStorage.getItem('state')!;

  // Validate callback parameters
  const params = oauth.validateAuthResponse(as, client, currentUrl, state);
  if (oauth.isOAuth2Error(params)) {
    throw new Error(`OAuth error: ${params.error_description || params.error}`);
  }

  // Exchange code for tokens
  const response = await oauth.authorizationCodeGrantRequest(
    as,
    client,
    params,
    redirectUri,
    codeVerifier
  );

  const result = await oauth.processAuthorizationCodeOpenIDResponse(as, client, response);
  if (oauth.isOAuth2Error(result)) {
    throw new Error(`Token error: ${result.error_description || result.error}`);
  }

  // Clean up
  sessionStorage.removeItem('code_verifier');
  sessionStorage.removeItem('state');

  return {
    accessToken: result.access_token,
    refreshToken: result.refresh_token,
    idToken: result.id_token,
  };
}

// Refresh token
async function refreshToken(refreshToken: string) {
  const as = await getAuthServer();
  const client: oauth.Client = { client_id: clientId };

  const response = await oauth.refreshTokenGrantRequest(as, client, refreshToken);
  const result = await oauth.processRefreshTokenResponse(as, client, response);

  if (oauth.isOAuth2Error(result)) {
    throw new Error(`Refresh error: ${result.error_description || result.error}`);
  }

  return result;
}
Next.js with NextAuth.js#
For Next.js applications, NextAuth.jsprovides a complete authentication solution.

bash
npm install next-auth
app/api/auth/[...nextauth]/route.ts
Components
typescript
import NextAuth from 'next-auth';

const handler = NextAuth({
  providers: [
    {
      id: 'uci',
      name: 'UCI',
      type: 'oauth',
      wellKnown: 'https://uci.space/.well-known/openid-configuration',
      clientId: process.env.UCI_CLIENT_ID,
      clientSecret: process.env.UCI_CLIENT_SECRET, // Optional for public clients
      authorization: { params: { scope: 'openid profile' } },
      checks: ['pkce', 'state'],
      idToken: true,
      profile(profile) {
        return {
          id: profile.sub,
          name: profile.name,
          email: profile.email,
        };
      },
    },
  ],
  callbacks: {
    async jwt({ token, account }) {
      if (account) {
        token.accessToken = account.access_token;
        token.refreshToken = account.refresh_token;
      }
      return token;
    },
    async session({ session, token }) {
      session.accessToken = token.accessToken;
      return session;
    },
  },
});

export { handler as GET, handler as POST };
Next Steps#
Device Authorization Guide - For devices with limited input (smart TVs, CLI tools, IoT)
M2M Integration Guide - For server-to-server authentication
Architecture Note#
UCI uses a dual-framework architecture:

API endpoints (/api/v1/*) are powered by FastAPI with JSON responses
Web UI (/auth/*, /account/*, /admin/*) is powered by Starlette with server-rendered templates
The OAuth2 endpoints (/oauth2/*) handle both browser redirects and API token requests depending on the operation.
